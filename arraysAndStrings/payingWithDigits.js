//Некоторые числа обладают забавными свойствами. Например:
//
// 89 --> 8¹ + 9² = 89 * 1
// 695 --> 6² + 9³ + 5⁴ = 1390 = 695 * 2
// 46288 --> 4³ + 6⁴ + 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

//Для двух положительных целых чисел n и p мы хотим найти положительное
// целое число k, если оно существует, такое что сумма цифр n, возведенных
// в последовательные степени, начиная с p, равна k * n.
//
// Другими словами, если мы записываем последовательные цифры n как a, b, c, d ..., существует ли целое число k такое, что:
//
// (a^p + b^(p+1) + c^(p+2) + d^(p+3) + ...) = n * k
//
// Если это так, то вернем k, если нет, вернем -1.
//
// Примечание: n и p всегда будут строго положительными целыми числами.
//
// Примеры:
// n = 89; p = 1 ---> 1, так как 8¹ + 9² = 89 = 89 * 1
//
// n = 92; p = 1 ---> -1, так как нет такого k, что 9¹ + 2² равно 92 * k
//
// n = 695; p = 2 ---> 2, так как 6² + 9³ + 5⁴ = 1390 = 695 * 2
//
// n = 46288; p = 3 ---> 51, так как 4³ + 6⁴ + 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51



function digPow(n, p) {
  let x = String(n).split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
  return x % n ? -1 : x / n
}